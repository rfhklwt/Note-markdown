## 遇到双字符串的问题



dp的定义都是跟题目一样：

比如这道题问：

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。



* 那么`dp[i][j]`就定义为字符串`sub_s = s[0: i]`和字符串`sub_t = t[0: j]`，计算在 `sub_s` 的子序列中 `sub_t` 出现的个数。

* 接着就可以算出转移方程：

1. 如果`sub_s`和`sub_t`的最后一个字符不同，那么求在 `sub_s = s[0: i]`的子序列中 `sub_t = t[0: j]`出现的个数。其实，就会变成求在`s[0: i - 1]`的子序列中 `sub_t = t[0: j]`出现的个数（因为最后的字符不同了，所以可以抛弃那个字符），而根据我们对`dp`的定义，求在`s[0: i - 1]`的子序列中 `sub_t = t[0: j]`出现的个数就是`dp[i - 1][j]`
2. 如果`sub_s`和`sub_t`的最后一个字符相同，那么就有两种情况：
   * 第一种就是这两个字符匹配，那么求在 `sub_s = s[0: i]`的子序列中 `sub_t = t[0: j]`出现的个数，就会变成求在 `sub_s = s[0: i - 1]`的子序列中 `sub_t = t[0: j - 1]`出现的个数，也就是`dp[i - 1][j - 1]`
   * 但我也可以是不匹配，虽然他们相等，但我可以不匹配，这样的话相当于求在`s[0: i - 1]`的子序列中 `sub_t = t[0: j]`出现的个数（因为不进行匹配，因此相当于不要那个字符，抛弃掉），而根据我们对`dp`的定义，求在`s[0: i - 1]`的子序列中 `sub_t = t[0: j]`出现的个数就是`dp[i - 1][j]`



* 所以总的情况就可以写成：

```python
if s[i - 1] == t[j - 1]:
    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]
else:
    dp[i][j] = dp[i - 1][j]
```



这里为啥是`t[i - 1] == s[j - 1]`呢？因为，我们会对`dp`多创建一个维度，来表示空字符串。比如`dp[1][0]`表示`s[0:1]`的子序列中`t[0:0]`出现的个数，假设`s = "abc", t = "wee"`，则`s[0:1] ='a', t[0: ] = ""`。



* 因为任何字符串的子序列都包含空字符串，所以，`dp`初始化为：

  ```python
  for i in range(m):
  	dp[i][0] = 1
  ```





总的代码为：

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        # dp[i][j]表示s[0:i]的子序列中t[0:j]出现的个数
        # 记得多加一个维度
        m, n = len(s) + 1, len(t) + 1
        # m × n矩阵
        dp = [[0] * n for _ in range(m)]
        # 任何字符串的子序列都包含一个空字符串，所以初始化为1
        for i in range(m):
            dp[i][0] = 1
        # 二维循环
        for i in range(1, m):
            for j in range(1, n):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[m][n]
```



